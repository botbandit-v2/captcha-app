<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<title>Проверка CAPTCHA</title>
	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
	<script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
	<script src="https://telegram.org/js/telegram-web-app.js"></script>
	<style>
		html,
		body {
			margin: 0;
			padding: 0;
			height: 100vh;
			width: 100vw;
			touch-action: manipulation;
			-webkit-text-size-adjust: 100%;
			-ms-text-size-adjust: 100%;
		}

		body {
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 0;
			box-sizing: border-box;
			background-color: var(--bg-color, #ffffff);
			transition: background-color 0.3s ease;
		}

		.captcha-wrapper {
			width: 100%;
			max-width: 360px;
			padding: 0 16px;
			box-sizing: border-box;
			display: flex;
			flex-direction: column;
			align-items: center;
			overflow-x: hidden;
		}

		.version-watermark {
			margin-top: 16px;
			text-align: center;
			font-size: 10px;
			color: rgba(128, 128, 128, 0.5);
			font-family: monospace;
			cursor: pointer;
			transition: all 0.2s ease;
			user-select: none;
		}
		
		/* уменьшенный отступ когда все статусы скрыты */
		.version-watermark.compact {
			margin-top: 8px;
		}

		.version-watermark:hover {
			color: rgba(128, 128, 128, 0.8);
		}

		.version-watermark:active {
			color: rgba(128, 128, 128, 1);
		}

		.status-indicator {
			margin-top: 12px;
			padding: 8px 12px;
			text-align: center;
			font-size: 12px;
			border-radius: 6px;
			font-family: system-ui, -apple-system, sans-serif;
			min-height: 16px;
			transition: all 0.3s ease;
			max-width: 100%;
			width: 100%;
			box-sizing: border-box;
		}

		.status-loading {
			background: rgba(0, 123, 255, 0.1);
			color: #007bff;
			border: 1px solid rgba(0, 123, 255, 0.3);
		}

		.status-success {
			background: rgba(40, 167, 69, 0.1);
			color: #28a745;
			border: 1px solid rgba(40, 167, 69, 0.3);
		}

		.status-error {
			background: rgba(220, 53, 69, 0.1);
			color: #dc3545;
			border: 1px solid rgba(220, 53, 69, 0.3);
			border-radius: 6px;
			white-space: pre-wrap;
			text-align: left;
			font-family: monospace;
			font-size: 11px;
			max-width: 100%;
			width: 100vw;
			box-sizing: border-box;
			word-wrap: break-word;
			word-break: break-all;
			overflow-wrap: break-word;
			margin-left: calc(-50vw + 50%);
			margin-right: calc(-50vw + 50%);
			padding: 8px 4px;
			max-height: 60vh;
			overflow-y: auto;
			position: relative;
			z-index: 9999;
		}

		.copy-button {
			background: #dc3545;
			color: white;
			border: 1px solid rgba(220, 53, 69, 0.3);
			border-radius: 6px;
			padding: 12px;
			font-size: 12px;
			cursor: pointer;
			font-family: system-ui, -apple-system, sans-serif;
			transition: background-color 0.2s ease;
			width: 100%;
			max-width: 100%;
			box-sizing: border-box;
			margin-top: 8px;
			margin-bottom: 0;
			text-align: center;
			font-weight: 500;
			display: block;
			outline: none;
		}

		.copy-button:hover {
			background: #c82333 !important;
		}

		.copy-button:active {
			background: #bd2130 !important;
		}

		.copy-button.copied {
			background: #28a745 !important;
		}

		.status-hidden {
			opacity: 0;
			height: 0;
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<div class="captcha-wrapper">
		<div id="captcha-container"></div>
		<div id="status-indicator" class="status-indicator status-hidden"></div>
		<button id="copy-button" class="copy-button status-hidden">копировать</button>
		<div class="version-watermark" onclick="showStatus('error', showDebugInfo())">v1.4.2d</div>
	</div>

	<script>
		let platform = 'unknown';
		let rawData = '';
		let theme = 'light';
		let submitting = false; // защита от двойной отправки
		let activeCaptchaType = 'unknown'; // отслеживаем какой виджет капчи загружен
		let captchaInitialized = false; // защита от повторной инициализации
		let captchaRenderTimeout = null; // таймаут для проверки рендеринга
		let turnstileSuccessfullyRendered = false; // флаг успешного рендера turnstile
		let turnstileVisualCheckTimeout = null; // таймаут для визуальной проверки
		
		// переключатель капчи для VK: true = Turnstile, false = hCaptcha
		const useCloudflareForVK = true;
		
		// отладочная информация о среде выполнения
		const debugInfo = 
		{
			userAgent: navigator.userAgent,
			isWebView: /wv/.test(navigator.userAgent) || /WebView/.test(navigator.userAgent) || 
					   (window.navigator.standalone === false && /Mobile/.test(navigator.userAgent)),
			isVKApp: /VKApp/.test(navigator.userAgent) && !window.Telegram?.WebApp?.initData,
			isTelegramApp: /Telegram/.test(navigator.userAgent) || !!window.Telegram?.WebApp?.initData,
			isAndroid: /Android/.test(navigator.userAgent),
			isIOS: /iPhone|iPad|iPod/.test(navigator.userAgent),
			platform: window.location.href.includes('vk.com') ? 'vk' : (window.Telegram?.WebApp?.initData ? 'telegram' : 'unknown'),
			location: window.location.href,
			referrer: document.referrer,
			windowFeatures: {
				width: window.innerWidth,
				height: window.innerHeight,
				devicePixelRatio: window.devicePixelRatio
			},
			allowsThirdPartyScripts: true, // будем проверять позже
			cspBlocked: false,
			networkBlocked: false,
			scriptsLoaded: {
				turnstile: false,
				hcaptcha: false
			},
			loadAttempts: {
				turnstile: 0,
				hcaptcha: 0
			},
			errors: [],
			logs: []
		};

		// функция для добавления логов 
		function addLog(message) 
		{
			const timestamp = new Date().toISOString().substr(11, 12);
			const logEntry = `[${timestamp}] ${message}`;
			debugInfo.logs.push(logEntry);
			console.log(`[DEBUG] ${message}`);
			
			// ограничиваем количество логов до 50
			if (debugInfo.logs.length > 50) 
			{
				debugInfo.logs.shift();
			}
		}

		function showDebugInfo() 
		{
			const debugText = [
				'=== ОТЛАДОЧНАЯ ИНФОРМАЦИЯ ===',
				`user agent: ${debugInfo.userAgent}`,
				`location: ${debugInfo.location}`,
				`referrer: ${debugInfo.referrer}`,
				`webview: ${debugInfo.isWebView}`,
				`vk app: ${debugInfo.isVKApp}`,
				`telegram app: ${debugInfo.isTelegramApp}`,
				`android: ${debugInfo.isAndroid}`,
				`ios: ${debugInfo.isIOS}`,
				`platform detected: ${debugInfo.platform}`,
				`window: ${debugInfo.windowFeatures.width}x${debugInfo.windowFeatures.height}`,
				`dpr: ${debugInfo.windowFeatures.devicePixelRatio}`,
				`scripts loaded: turnstile=${debugInfo.scriptsLoaded.turnstile}, hcaptcha=${debugInfo.scriptsLoaded.hcaptcha}`,
				`load attempts: turnstile=${debugInfo.loadAttempts.turnstile}, hcaptcha=${debugInfo.loadAttempts.hcaptcha}`,
				`active captcha type: ${activeCaptchaType}`,
				`csp blocked: ${debugInfo.cspBlocked}`,
				`network blocked: ${debugInfo.networkBlocked}`,
				`third party scripts: ${debugInfo.allowsThirdPartyScripts}`,
				`errors: ${debugInfo.errors.length > 0 ? debugInfo.errors.join('; ') : 'none'}`,
				'',
				'=== EXECUTION LOGS ===',
				...(debugInfo.logs.length > 0 ? debugInfo.logs : ['no logs yet']),
				'================================'
			].join('\n');
			return debugText;
		}

		function showStatus(type, message) 
		{
			const indicator = document.getElementById('status-indicator');
			const copyButton = document.getElementById('copy-button');
			const watermark = document.querySelector('.version-watermark');

			// добавляем отладочную информацию к ошибкам в webview
			if (type === 'error' && debugInfo.isWebView) 
			{
				message = message + '\n\n' + showDebugInfo();
			}

			indicator.className = `status-indicator status-${type}`;
			indicator.textContent = message;

			// убираем compact класс когда показываем статус
			if (watermark) {
				watermark.classList.remove('compact');
			}

			if (type === 'error') 
			{
				copyButton.className = 'copy-button';
				copyButton.onclick = () => copyErrorText(message, copyButton);
			} else 
			{
				copyButton.className = 'copy-button status-hidden';
			}
		}

		function hideStatus() {
			const indicator = document.getElementById('status-indicator');
			const copyButton = document.getElementById('copy-button');
			const watermark = document.querySelector('.version-watermark');

			indicator.className = 'status-indicator status-hidden';
			copyButton.className = 'copy-button status-hidden';
			
			// добавляем compact класс когда все элементы скрыты
			if (watermark) {
				watermark.classList.add('compact');
			}
		}

		async function copyErrorText(text, button) {
			try {
				await navigator.clipboard.writeText(text);
				const originalText = button.textContent;
				button.textContent = 'скопировано';
				button.classList.add('copied');

				setTimeout(() => {
					button.textContent = originalText;
					button.classList.remove('copied');
				}, 2000);
			} catch (err) {
				const textArea = document.createElement('textarea');
				textArea.value = text;
				textArea.style.position = 'fixed';
				textArea.style.left = '-999999px';
				textArea.style.top = '-999999px';
				document.body.appendChild(textArea);
				textArea.focus();
				textArea.select();

				try {
					document.execCommand('copy');
					button.textContent = 'скопировано';
					button.classList.add('copied');

					setTimeout(() => {
						button.textContent = 'копировать';
						button.classList.remove('copied');
					}, 2000);
				} catch (err2) {
					button.textContent = 'ошибка';
					setTimeout(() => {
						button.textContent = 'копировать';
					}, 2000);
				}

				document.body.removeChild(textArea);
			}
		}

		// проверка CSP и блокировки скриптов
		function checkCSPAndScriptBlocking() 
		{
			return new Promise(async (resolve) => 
			{
				// проверяем CSP
				const testScript = document.createElement('script');
				testScript.src = 'data:text/javascript;base64,'; // пустой data URI
				testScript.onload = () => 
				{
					debugInfo.allowsThirdPartyScripts = true;
					debugInfo.cspBlocked = false;
				};
				testScript.onerror = () => 
				{
					debugInfo.allowsThirdPartyScripts = false;
					debugInfo.cspBlocked = true;
					debugInfo.errors.push('CSP blocks data URIs');
				};
				
				document.head.appendChild(testScript);
				
				// ждём немного для CSP проверки
				await new Promise(r => setTimeout(r, 500));
				
				// проверяем сетевую доступность к серверам капчи
				try 
				{
					const turnstileCheck = fetch('https://challenges.cloudflare.com/turnstile/v0/api.js', { 
						method: 'HEAD', 
						mode: 'no-cors',
						cache: 'no-cache'
					}).catch(() => false);
					
					const hcaptchaCheck = fetch('https://hcaptcha.com/1/api.js', { 
						method: 'HEAD', 
						mode: 'no-cors',
						cache: 'no-cache'
					}).catch(() => false);
					
					const [turnstileOk, hcaptchaOk] = await Promise.allSettled([turnstileCheck, hcaptchaCheck]);
					
					if (turnstileOk.status === 'rejected' && hcaptchaOk.status === 'rejected') 
					{
						debugInfo.networkBlocked = true;
						debugInfo.errors.push('Network access to captcha servers blocked');
					}
				} catch (e) 
				{
					debugInfo.errors.push(`Network check failed: ${e.message}`);
				}
				
				resolve();
			});
		}

		// функция для безопасной загрузки скриптов с фолбэками
		function loadScriptWithFallback(src, onLoad, onError, scriptType = 'unknown') 
		{
			// увеличиваем счётчик попыток
			if (scriptType === 'turnstile') debugInfo.loadAttempts.turnstile++;
			if (scriptType === 'hcaptcha') debugInfo.loadAttempts.hcaptcha++;
			
			const script = document.createElement('script');
			script.async = true;
			script.defer = true;
			
			let loaded = false;
			let timeoutId;
			
			const cleanup = () => 
			{
				if (timeoutId) clearTimeout(timeoutId);
				script.onload = null;
				script.onerror = null;
			};
			
			script.onload = () => 
			{
				if (loaded) return;
				loaded = true;
				cleanup();
				addLog(`Script loaded successfully: ${src}`);
				if (onLoad) onLoad();
			};
			
			script.onerror = (error) => 
			{
				if (loaded) return;
				loaded = true;
				cleanup();
				const errorMsg = `Script load error: ${src}`;
				addLog(errorMsg);
				debugInfo.errors.push(errorMsg);
				if (onError) onError();
			};
			
			// таймаут для webview, где скрипты могут блокироваться молча
			timeoutId = setTimeout(() => 
			{
				if (loaded) return;
				loaded = true;
				cleanup();
				const timeoutMsg = `Script load timeout: ${src}`;
				addLog(timeoutMsg);
				debugInfo.errors.push(timeoutMsg);
				if (onError) onError();
			}, 15000); // увеличил таймаут до 15 секунд
			
			addLog(`Loading script: ${src}`);
			script.src = src;
			document.head.appendChild(script);
		}

		// функция для парсинга VK параметров из URL
		function getVKLaunchParams() 
		{
			const params = new URLSearchParams(window.location.search);
			const vkParams = {};
			
			// собираем все параметры с префиксом 'vk_' и 'sign'
			for (const [key, value] of params.entries()) 
			{
				if (key.startsWith('vk_') || key === 'sign') 
				{
					vkParams[key] = value;
				}
			}
			
			addLog(`VK params from URL: ${Object.keys(vkParams).length} parameters found`);
			return vkParams;
		}

		// начальный лог
		addLog('Application started');
		addLog(`Detected platform: isTelegram=${!!window.Telegram?.WebApp?.initData}, isVK=${!window.Telegram?.WebApp?.initData}`);
		
		// принудительно очищаем все возможные остатки от предыдущих сессий
		const captchaContainer = document.getElementById('captcha-container');
		if (captchaContainer) 
		{
			captchaContainer.innerHTML = '';
			addLog('Cleared captcha container on startup');
		}
		
		// инициализируем compact класс для watermark
		const watermark = document.querySelector('.version-watermark');
		if (watermark) {
			watermark.classList.add('compact');
		}

		const isTelegram = window.Telegram?.WebApp?.initData;
		const isVK = !isTelegram;

		function applyTheme(theme) 
		{
			document.body.style.setProperty('--bg-color', theme === 'dark' ? '#000000' : '#ffffff');
			// НЕ перерендериваем капчи при смене темы - это вызывает дублирование
			// Капчи должны рендериться только один раз при загрузке приложения
			addLog(`Theme applied: ${theme}, but skipping captcha re-render`);
		}

		function insertTelegramCaptcha() 
		{
			const container = document.getElementById('captcha-container');
			// создаём элемент без data-атрибутов для предотвращения автоматического рендера
			container.innerHTML = '';
			const turnstileDiv = document.createElement('div');
			turnstileDiv.id = 'telegram-turnstile';
			turnstileDiv.className = 'cf-turnstile-manual';
			container.appendChild(turnstileDiv);

			const existingScript = document.querySelector('script[src*="turnstile"]');
			if (!existingScript) 
			{
				showStatus('loading', 'загружается turnstile...');
				loadScriptWithFallback(
					'https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit',
					() => 
					{
						debugInfo.scriptsLoaded.turnstile = true;
						activeCaptchaType = 'turnstile';
						
						// принудительно рендерим turnstile виджет для telegram
						setTimeout(() => 
						{
							addLog('Attempting to render Turnstile widget for Telegram...');
							if (window.turnstile && window.turnstile.render) 
							{
								const container = document.getElementById('telegram-turnstile');
								if (container) 
								{
									try 
									{
										addLog('Rendering Turnstile widget with API for Telegram...');
										const widgetId = window.turnstile.render(container, {
											sitekey: '0x4AAAAAABvVfFdKvgN--jG6',
											callback: (token) => {
												turnstileSuccessfullyRendered = true;
												addLog('Turnstile callback triggered - widget confirmed working');
												// отменяем проверку таймаута если callback сработал
												if (turnstileVisualCheckTimeout) {
													clearTimeout(turnstileVisualCheckTimeout);
													turnstileVisualCheckTimeout = null;
													addLog('Visual check timeout cancelled due to successful callback');
												}
												onCaptchaSuccess(token);
											},
											theme: theme === 'dark' ? 'dark' : 'light'
										});
										addLog(`Turnstile render call completed, widget ID: ${widgetId}`);
										
										// дополнительная проверка через 3 секунды - реально ли отобразился виджет
										turnstileVisualCheckTimeout = setTimeout(() => 
										{
											// более широкий поиск элементов Turnstile
											const iframe = container.querySelector('iframe');
											const widgetDiv = container.querySelector('div[data-sitekey]');
											const cfTurnstileDiv = container.querySelector('.cf-turnstile');
											const anyTurnstileElement = container.querySelector('div[id*="turnstile"], div[class*="turnstile"], iframe[src*="cloudflare"]');
											const containerHasChildren = container.children.length > 1; // больше чем просто наш div
											
											// получаем детальную информацию о содержимом контейнера
											const containerHTML = container.innerHTML;
											const containerChildrenInfo = Array.from(container.children).map(child => ({
												tagName: child.tagName,
												className: child.className,
												id: child.id,
												hasChildren: child.children.length > 0
											}));
											
											addLog(`Turnstile visual check details:`);
											addLog(`- iframe: ${!!iframe}`);
											addLog(`- widgetDiv: ${!!widgetDiv}`);
											addLog(`- cfTurnstileDiv: ${!!cfTurnstileDiv}`);
											addLog(`- anyTurnstileElement: ${!!anyTurnstileElement}`);
											addLog(`- containerHasChildren: ${containerHasChildren}`);
											addLog(`- container children count: ${container.children.length}`);
											addLog(`- children info: ${JSON.stringify(containerChildrenInfo)}`);
											
											// более гибкие условия для определения успешного рендера
											const hasVisibleContent = iframe || widgetDiv || cfTurnstileDiv || anyTurnstileElement || containerHasChildren;
											
											// дополнительная проверка - есть ли в HTML что-то похожее на turnstile
											const htmlHasTurnstileContent = containerHTML.includes('turnstile') || 
																		   containerHTML.includes('cloudflare') || 
																		   containerHTML.includes('iframe') ||
																		   containerHTML.length > 100; // если много контента, скорее всего виджет загрузился
											
											const finalCheck = hasVisibleContent || htmlHasTurnstileContent || turnstileSuccessfullyRendered;
											
											addLog(`Final render check: hasVisibleContent=${hasVisibleContent}, htmlHasTurnstileContent=${htmlHasTurnstileContent}, callbackTriggered=${turnstileSuccessfullyRendered}, finalCheck=${finalCheck}`);
											
											if (!finalCheck) 
											{
												addLog('Turnstile widget not visually rendered in Telegram, switching to hCaptcha');
												addLog(`Container HTML was: ${containerHTML.substring(0, 200)}...`);
												debugInfo.errors.push('Turnstile widget not visually rendered');
												container.innerHTML = '';
												turnstileSuccessfullyRendered = false; // сброс флага
												insertTelegramHCaptcha();
											} else 
											{
												addLog('Turnstile widget successfully rendered and visible');
												hideStatus();
											}
											turnstileVisualCheckTimeout = null; // очищаем ссылку на таймаут
										}, 3000);
									} catch (e) 
									{
										addLog(`Turnstile render error: ${e.message}`);
										debugInfo.errors.push(`Turnstile render error: ${e.message}`);
										container.innerHTML = '';
										insertTelegramHCaptcha();
									}
								} else 
								{
									addLog('Turnstile container not found');
									insertTelegramHCaptcha();
								}
							} else 
							{
								addLog('Turnstile API not available');
								insertTelegramHCaptcha();
							}
						}, 100);
					},
					() => 
					{
						debugInfo.scriptsLoaded.turnstile = false;
						addLog('Turnstile script failed to load, switching to hCaptcha');
						insertTelegramHCaptcha();
					},
					'turnstile'
				);
			} else 
			{
				addLog('Turnstile script already loaded, attempting direct render');
				hideStatus();
			}
		}
		
		function insertTelegramHCaptcha() 
		{
			addLog('insertTelegramHCaptcha called');
			const container = document.getElementById('captcha-container');
			container.innerHTML = `
        <div class="h-captcha" 
             data-sitekey="5ae63666-6d46-47b0-ad48-a96829a83a7a" 
             data-callback="onCaptchaSuccess" 
             data-theme="${theme}">
        </div>`;

			showStatus('loading', 'загружается hcaptcha для telegram...');
			loadScriptWithFallback(
				'https://hcaptcha.com/1/api.js?hl=ru&onload=hcaptchaLoadedTelegram',
				() => 
				{
					addLog('hCaptcha script loaded successfully for Telegram');
					debugInfo.scriptsLoaded.hcaptcha = true;
					activeCaptchaType = 'hcaptcha';
				},
				() => 
				{
					addLog('hCaptcha script failed to load for Telegram');
					debugInfo.scriptsLoaded.hcaptcha = false;
					showStatus('error', 'не удалось загрузить hcaptcha скрипт. проблемы с сетью или блокировка.');
				},
				'hcaptcha'
			);
		}
		
		function hcaptchaLoadedTelegram() 
		{
			addLog('hcaptchaLoadedTelegram callback called');
			const container = document.querySelector('.h-captcha');
			if (container && window.hcaptcha) 
			{
				try 
				{
					addLog('Rendering hCaptcha widget for Telegram...');
					window.hcaptcha.render(container);
					addLog('hCaptcha widget rendered successfully for Telegram');
					hideStatus();
				} catch (e) 
				{
					addLog(`hCaptcha render error for Telegram: ${e.message}`);
					showStatus('error', `hcaptcha render error: ${e.message}`);
				}
			} else 
			{
				addLog('hCaptcha render failed for Telegram - missing container or hcaptcha object');
				showStatus('error', 'hcaptcha загружен, но не найден контейнер или объект hcaptcha');
			}
		}

		function insertVKCaptcha() 
		{
			// защита от повторных вызовов
			if (captchaInitialized) 
			{
				addLog('Captcha already initialized, skipping...');
				return;
			}
			
			addLog(`insertVKCaptcha called, useCloudflareForVK: ${useCloudflareForVK}`);
			captchaInitialized = true;
			
			if (useCloudflareForVK) 
			{
				addLog('Calling insertVKTurnstileCaptcha');
				insertVKTurnstileCaptcha();
			} else 
			{
				addLog('Calling insertVKHCaptcha');
				insertVKHCaptcha();
			}
		}
		
		function insertVKTurnstileCaptcha() 
		{
			addLog('insertVKTurnstileCaptcha called');
			
			// строгая защита - проверяем наличие любых дочерних элементов в контейнере
			const container = document.getElementById('captcha-container');
			if (container.children.length > 0) 
			{
				addLog('Captcha container not empty, skipping render to prevent duplicates');
				return;
			}
			
			// уникальный ID для предотвращения конфликтов
			const uniqueId = 'turnstile-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
			addLog(`Creating Turnstile widget with unique ID: ${uniqueId}`);
			
			// создаём новый div для turnstile с уникальным ID
			// НЕ используем data-* атрибуты чтобы избежать автоматического рендера
			const turnstileDiv = document.createElement('div');
			turnstileDiv.id = uniqueId;
			turnstileDiv.className = 'cf-turnstile-manual'; // изменили класс
			// НЕ добавляем data-sitekey и другие data-* атрибуты
			container.appendChild(turnstileDiv);
			
			const existingScript = document.querySelector('script[src*="turnstile"]');
			addLog(`Existing turnstile script: ${existingScript ? 'found' : 'not found'}`);
			
			if (!existingScript) 
			{
				addLog('Loading turnstile script...');
				showStatus('loading', 'загружается turnstile для vk...');
				loadScriptWithFallback(
					'https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit',
					() => 
					{
						addLog('Turnstile script loaded successfully');
						debugInfo.scriptsLoaded.turnstile = true;
						activeCaptchaType = 'turnstile';
						
						// принудительно рендерим turnstile виджет (особенно для iOS WebView)
						setTimeout(() => 
						{
							addLog('Attempting to render Turnstile widget...');
							if (window.turnstile && window.turnstile.render) 
							{
								const containerElement = document.getElementById(uniqueId);
								if (containerElement) 
								{
									try 
									{
										addLog(`Rendering Turnstile widget with API on container: ${uniqueId}`);
										// используем render с конкретным элементом
										window.turnstile.render(containerElement, {
											sitekey: '0x4AAAAAABvVfFdKvgN--jG6',
											callback: onCaptchaSuccess,
											theme: theme === 'dark' ? 'dark' : 'light'
										});
										addLog('Turnstile widget rendered successfully');
										// отменяем таймаут проверки, т.к. рендеринг прошёл успешно
										if (captchaRenderTimeout) 
										{
											clearTimeout(captchaRenderTimeout);
											captchaRenderTimeout = null;
										}
									} catch (e) 
									{
										addLog(`Turnstile render error: ${e.message}`);
										// если turnstile не рендерится на iOS, переключаемся на hCaptcha
										if (debugInfo.isIOS) 
										{
											addLog('Switching to hCaptcha due to iOS Turnstile render failure');
											captchaInitialized = false; // сбрасываем флаг
											setTimeout(() => insertVKHCaptcha(), 500);
										}
									}
								} else 
								{
									addLog(`Turnstile container ${uniqueId} not found`);
									// если контейнер не найден на iOS, переключаемся на hCaptcha
									if (debugInfo.isIOS) 
									{
										addLog('Switching to hCaptcha due to missing Turnstile container on iOS');
										captchaInitialized = false; // сбрасываем флаг
										setTimeout(() => insertVKHCaptcha(), 500);
									}
								}
							} else 
							{
								addLog('Turnstile API not available for manual render');
								// если API недоступен на iOS, переключаемся на hCaptcha
								if (debugInfo.isIOS) 
								{
									addLog('Switching to hCaptcha due to unavailable Turnstile API on iOS');
									captchaInitialized = false; // сбрасываем флаг
									setTimeout(() => insertVKHCaptcha(), 500);
								}
							}
						}, 100);
						
						// отменяем предыдущий таймаут если есть
						if (captchaRenderTimeout) 
						{
							clearTimeout(captchaRenderTimeout);
						}
						
						// дополнительная проверка через 3 секунды - рендерился ли виджет
						captchaRenderTimeout = setTimeout(() => 
						{
							const widget = document.querySelector('.cf-turnstile iframe') || document.querySelector('.cf-turnstile div[data-sitekey]');
							if (!widget && debugInfo.isIOS && activeCaptchaType !== 'hcaptcha') 
							{
								addLog('Turnstile widget not rendered after 3 seconds on iOS, switching to hCaptcha');
								captchaInitialized = false; // сбрасываем флаг чтобы разрешить hCaptcha
								insertVKHCaptcha();
							} else if (widget) 
							{
								addLog('Turnstile widget successfully rendered and visible');
							}
						}, 3000);
						
						hideStatus();
					},
					() => 
					{
						addLog('Turnstile script failed to load');
						debugInfo.scriptsLoaded.turnstile = false;
						// если turnstile не загрузился в VK, переключаемся на hCaptcha
						if (debugInfo.isWebView || debugInfo.isAndroid) 
						{
							addLog('Switching to hCaptcha due to failure');
							captchaInitialized = false; // сбрасываем флаг
							showStatus('loading', 'turnstile заблокирован, переключаемся на hcaptcha...');
							setTimeout(() => insertVKHCaptcha(), 1000);
						} else 
						{
							showStatus('error', 'не удалось загрузить turnstile скрипт.');
						}
					},
					'turnstile'
				);
			} else 
			{
				addLog('Turnstile script already exists, skipping load');
				hideStatus();
			}
		}
		
		function insertVKHCaptcha() 
		{
			addLog('insertVKHCaptcha called');
			
			const container = document.getElementById('captcha-container');
			container.innerHTML = `
        <div class="h-captcha" 
             data-sitekey="5ae63666-6d46-47b0-ad48-a96829a83a7a" 
             data-callback="onCaptchaSuccess" 
             data-theme="${theme}">
        </div>`;

			const existingScript = document.querySelector('script[src*="hcaptcha"]');
			if (existingScript) 
			{
				addLog('Removing existing hCaptcha script');
				existingScript.remove();
			}

			addLog('Loading hCaptcha script...');
			showStatus('loading', 'загружается hcaptcha...');
			loadScriptWithFallback(
				'https://hcaptcha.com/1/api.js?hl=ru&onload=hcaptchaLoaded',
				() => 
				{
					addLog('hCaptcha script loaded successfully');
					debugInfo.scriptsLoaded.hcaptcha = true;
					activeCaptchaType = 'hcaptcha';
					// hideStatus будет вызван в hcaptchaLoaded
				},
				() => 
				{
					addLog('hCaptcha script failed to load');
					debugInfo.scriptsLoaded.hcaptcha = false;
					showStatus('error', 'не удалось загрузить hcaptcha скрипт. возможно заблокирован в webview.');
				},
				'hcaptcha'
			);
		}

		function hcaptchaLoaded() 
		{
			addLog('hcaptchaLoaded callback called');
			const container = document.querySelector('.h-captcha');
			addLog(`hCaptcha container found: ${container ? 'yes' : 'no'}`);
			addLog(`window.hcaptcha exists: ${window.hcaptcha ? 'yes' : 'no'}`);
			
			if (container && window.hcaptcha) 
			{
				try 
				{
					addLog('Rendering hCaptcha widget...');
					window.hcaptcha.render(container);
					addLog('hCaptcha widget rendered successfully');
					hideStatus();
				} catch (e) 
				{
					addLog(`hCaptcha render error: ${e.message}`);
					showStatus('error', `hcaptcha render error: ${e.message}`);
				}
			} else 
			{
				addLog('hCaptcha render failed - missing container or hcaptcha object');
				showStatus('error', 'hcaptcha загружен, но не найден контейнер или объект hcaptcha');
			}
		}

		if (isTelegram) {
			const tg = window.Telegram.WebApp;
			platform = 'tg';
			rawData = encodeURIComponent(JSON.stringify(tg.initDataUnsafe));
			theme = tg.colorScheme;
			tg.ready();

			tg.onEvent('themeChanged', () => {
				theme = tg.colorScheme;
				applyTheme(theme);
				insertTelegramCaptcha();
			});

			applyTheme(theme);
			insertTelegramCaptcha();

		} else if (isVK) 
		{
			platform = 'vk';
			addLog('Starting VK initialization...');
			addLog(`vkBridge available: ${typeof vkBridge !== 'undefined'}`);

			// загружаем капчу сразу, не дожидаясь VK Bridge
			addLog('Loading captcha immediately (not waiting for VK Bridge)');
			platform = 'vk';
			theme = 'light';
			
			// получаем VK параметры из URL вместо ожидания vkBridge
			const vkLaunchParams = getVKLaunchParams();
			rawData = encodeURIComponent(JSON.stringify(vkLaunchParams));
			addLog('Using VK params from URL for rawData');
			
			insertVKCaptcha();

			// параллельно пытаемся инициализировать VK Bridge для получения темы и данных
			(async () => 
			{
				try 
				{
					// проверяем доступность vkBridge
					if (typeof vkBridge === 'undefined') 
					{
						addLog('vkBridge not available, using fast mode only');
						return;
					}

					addLog('Trying VK Bridge init in background...');
					
					// добавляем таймаут для VK Bridge инициализации
					const initPromise = vkBridge.send('VKWebAppInit');
					const timeoutPromise = new Promise((_, reject) => 
						setTimeout(() => reject(new Error('VK Bridge init timeout')), 3000)
					);
					
					try 
					{
						await Promise.race([initPromise, timeoutPromise]);
						addLog('VK Bridge initialized successfully');
						
						addLog('Getting launch params...');
						const launchParams = await vkBridge.send('VKWebAppGetLaunchParams');
						rawData = encodeURIComponent(JSON.stringify(launchParams));
						addLog('Launch params received, updating rawData');

						addLog('Getting config...');
						const config = await vkBridge.send('VKWebAppGetConfig');
						const newTheme = config.scheme?.includes('dark') ? 'dark' : 'light';
						if (newTheme !== theme) 
						{
							theme = newTheme;
							applyTheme(theme);
							addLog(`Theme updated to: ${theme}`);
						}

						vkBridge.subscribe(e => 
						{
							if (e.detail.type === 'VKWebAppUpdateConfig') 
							{
								const newScheme = e.detail.data.scheme || 'bright_light';
								const newTheme = newScheme.includes('dark') ? 'dark' : 'light';
								if (newTheme !== theme) 
								{
									theme = newTheme;
									applyTheme(theme);
									addLog(`Theme changed to: ${newTheme}`);
									// НЕ перерендериваем капчу при смене темы - это вызывает дублирование
									// insertVKCaptcha(); // УБРАНО
								}
							}
						});

					} catch (initError) 
					{
						addLog(`VK Bridge init failed in background: ${initError.message}`);
						// не проблема, капча уже загружена
					}
				} catch (err) 
				{
					addLog(`VK background init error: ${err.toString()}`);
					// не критично, основная функциональность уже работает
				}
			})();
		}

		async function onCaptchaSuccess(token) 
		{
			addLog(`onCaptchaSuccess called with token: ${token ? token.substring(0, 20) + '...' : 'null'}`);
			
			if (submitting) 
			{
				addLog('Already submitting, skipping duplicate');
				return; // не шлём дубли
			}
			submitting = true;

			showStatus('loading', 'проверяем капчу...');
			const encodedToken = encodeURIComponent(token);

			// основной и резервный endpoints
			const primaryEndpoint = 'https://api.cf-botbandit.com/captcha/';
			const fallbackEndpoint = 'https://dp-api.cf-botbandit.com/captcha/';
			// const endPoint = 'https://slots.botbandit.com/captcha.php';

			const tryEndpoint = async (endpoint, isFallback = false) => 
			{
				const url = `${endpoint}?captcha=${encodedToken}&rawData=${rawData}&platform=${platform}&captchaType=${activeCaptchaType}`;
				
				addLog(`=== ${isFallback ? 'FALLBACK' : 'PRIMARY'} ENDPOINT ATTEMPT ===`);
				addLog(`Endpoint: ${endpoint}`);
				addLog(`Full URL: ${url.substring(0, 150)}...`);
				addLog(`Platform: ${platform}, CaptchaType: ${activeCaptchaType}`);
				
				if (isFallback) 
				{
					showStatus('loading', 'пробуем резервный сервер...');
				}

				const startTime = Date.now();
				const controller = new AbortController();
				const timeoutId = setTimeout(() => 
				{
					addLog(`Request timeout after 15 seconds to ${endpoint}`);
					controller.abort();
				}, 15000);

				try 
				{
					addLog(`Sending fetch request to ${endpoint}...`);
					const res = await fetch(url, {
						signal: controller.signal,
						method: 'GET',
						mode: 'cors',
						headers: { 'Accept': 'application/json, text/plain;q=0.9, */*;q=0.8' },
						cache: 'no-store'
					});

					clearTimeout(timeoutId);
					const responseTime = Date.now() - startTime;
					
					addLog(`Response received from ${endpoint} in ${responseTime}ms`);
					addLog(`HTTP Status: ${res.status} ${res.statusText}`);
					addLog(`Response headers: ${JSON.stringify(Object.fromEntries(res.headers.entries()))}`);

					const text = await res.text();
					addLog(`Response body length: ${text.length} characters`);
					addLog(`Response body preview: ${text.substring(0, 200)}${text.length > 200 ? '...' : ''}`);
					
					let data = null;
					let parseError = null;
					try 
					{ 
						data = JSON.parse(text); 
						addLog(`JSON parsing successful`);
					} catch (e) 
					{ 
						parseError = e.message;
						addLog(`JSON parsing failed: ${e.message}`);
					}

					const success = res.ok && data && data.success;
					addLog(`Final success check: res.ok=${res.ok}, data=${!!data}, data.success=${data?.success}, final=${success}`);
					
					if (!res.ok) 
					{
						addLog(`HTTP error detected: ${res.status} ${res.statusText}`);
					}
					
					if (data && !data.success) 
					{
						addLog(`Server returned success=false. Full data: ${JSON.stringify(data)}`);
					}

					const result = { 
						success, 
						data, 
						text, 
						status: res.status, 
						statusText: res.statusText,
						url,
						responseTime,
						parseError,
						endpoint: isFallback ? 'fallback' : 'primary'
					};
					
					addLog(`=== ${isFallback ? 'FALLBACK' : 'PRIMARY'} ENDPOINT ${success ? 'SUCCESS' : 'FAILED'} ===`);
					return result;
				} catch (e) 
				{
					clearTimeout(timeoutId);
					const responseTime = Date.now() - startTime;
					
					addLog(`=== ${isFallback ? 'FALLBACK' : 'PRIMARY'} ENDPOINT ERROR ===`);
					addLog(`Error type: ${e.name}`);
					addLog(`Error message: ${e.message}`);
					addLog(`Error after: ${responseTime}ms`);
					addLog(`Stack trace: ${e.stack?.substring(0, 300) || 'not available'}`);
					
					// детализируем тип ошибки
					if (e.name === 'AbortError') 
					{
						addLog(`Request was aborted (timeout or manual cancellation)`);
					} else if (e.name === 'TypeError' && e.message.includes('fetch')) 
					{
						addLog(`Network error: likely CORS, DNS, or connection issue`);
					} else if (e.name === 'TypeError' && e.message.includes('NetworkError')) 
					{
						addLog(`Network error: connection failed or blocked`);
					}
					
					throw e;
				}
			};

			try 
			{
				showStatus('loading', 'загрузка...');
				addLog(`\n=== CAPTCHA VERIFICATION STARTED ===`);
				addLog(`Total endpoints to try: 2 (primary + fallback)`);
				
				let result;
				let usedEndpoint = 'none';
				
				// сначала пробуем основной endpoint
				try 
				{
					addLog(`\n--- Attempting PRIMARY endpoint ---`);
					result = await tryEndpoint(primaryEndpoint, false);
					usedEndpoint = 'primary';
					addLog(`Primary endpoint completed successfully`);
				} catch (primaryError) 
				{
					addLog(`\n--- PRIMARY ENDPOINT FAILED ---`);
					addLog(`Primary error: ${primaryError.name} - ${primaryError.message}`);
					
					// если основной не работает, пробуем резервный
					try 
					{
						addLog(`\n--- Attempting FALLBACK endpoint ---`);
						result = await tryEndpoint(fallbackEndpoint, true);
						usedEndpoint = 'fallback';
						addLog(`Fallback endpoint completed successfully`);
					} catch (fallbackError) 
					{
						addLog(`\n--- FALLBACK ENDPOINT FAILED ---`);
						addLog(`Fallback error: ${fallbackError.name} - ${fallbackError.message}`);
						addLog(`\n=== ALL ENDPOINTS FAILED ===`);
						
						const detailedError = {
							primary: {
								endpoint: primaryEndpoint,
								error: primaryError.message,
								type: primaryError.name
							},
							fallback: {
								endpoint: fallbackEndpoint,
								error: fallbackError.message,
								type: fallbackError.name
							}
						};
						
						addLog(`Detailed failure info: ${JSON.stringify(detailedError, null, 2)}`);
						throw new Error(`оба сервера недоступны. основной: ${primaryError.message}, резервный: ${fallbackError.message}`);
					}
				}

				addLog(`\n=== PROCESSING RESPONSE ===`);
				addLog(`Used endpoint: ${usedEndpoint} (${result.endpoint})`);
				addLog(`Response time: ${result.responseTime}ms`);
				addLog(`HTTP status: ${result.status} ${result.statusText || ''}`);
				addLog(`Success flag: ${result.success}`);
				
				showStatus('loading', 'обработка...');

				if (result.success) 
				{
					addLog(`\n=== VERIFICATION SUCCESS ===`);
					addLog(`Platform: ${platform}`);
					addLog(`Final success with ${usedEndpoint} endpoint`);
					
					showStatus('success', 'проверка пройдена! можно закрыть это окно.');
					setTimeout(() => 
					{
						if (platform === 'tg') 
						{
							addLog(`Sending data to Telegram and closing...`);
							window.Telegram.WebApp.sendData('verified');
							setTimeout(() => { window.Telegram.WebApp.close(); }, 50);
						} else if (platform === 'vk') 
						{
							addLog(`Closing VK WebApp...`);
							vkBridge.send('VKWebAppClose', { status: 'success' });
						}
					}, 50);
				} else 
				{
					addLog(`\n=== VERIFICATION FAILED ===`);
					addLog(`Response indicated failure despite HTTP success`);
					addLog(`Data: ${JSON.stringify(result.data, null, 2)}`);
					addLog(`Raw text: ${result.text}`);
					
					const errorDetails = [
						`=== ДЕТАЛИ ОШИБКИ ВЕРИФИКАЦИИ ===`,
						`Endpoint: ${usedEndpoint} (${result.url})`,
						`HTTP Status: ${result.status} ${result.statusText || ''}`,
						`Response Time: ${result.responseTime}ms`,
						`Platform: ${platform}`,
						`Captcha Type: ${activeCaptchaType}`,
						`Parse Error: ${result.parseError || 'none'}`,
						``,
						`Response Data:`,
						result.data ? JSON.stringify(result.data, null, 2) : (result.text || `HTTP ${result.status}`),
						``,
						`Full URL: ${result.url}`
					].join('\n');
					
					showStatus('error', errorDetails);
					if (window.hcaptcha && platform === 'vk') window.hcaptcha.reset();
					if (window.turnstile && platform === 'tg') window.turnstile.reset();
					// небольшая пауза, чтобы Cloudflare/Google не засчитал дубликат
					setTimeout(() => { submitting = false; }, 400);
					return;
				}
			} catch (e) 
			{
				addLog(`\n=== CRITICAL ERROR ===`);
				addLog(`Error type: ${e.name}`);
				addLog(`Error message: ${e.message}`);
				addLog(`Stack trace: ${e.stack?.substring(0, 500) || 'not available'}`);
				
				let userFriendlyError;
				if (e.name === 'AbortError') 
				{
					userFriendlyError = 'превышено время ожидания ответа от серверов (15 сек)';
					addLog(`User shown: timeout error`);
				} else if (e.message.includes('оба сервера недоступны')) 
				{
					userFriendlyError = String(e.message);
					addLog(`User shown: both servers failed`);
				} else 
				{
					userFriendlyError = `ошибка сети: ${String(e)}`;
					addLog(`User shown: network error`);
				}
				
				showStatus('error', userFriendlyError);
				
				if (window.hcaptcha && platform === 'vk') window.hcaptcha.reset();
				if (window.turnstile && platform === 'tg') window.turnstile.reset();
				setTimeout(() => { submitting = false; }, 400);
				return;
			}

			// успех — можно снова принимать попытки (если вдруг не закрыли окно)
			setTimeout(() => { submitting = false; }, 1000);
		}
	</script>
</body>

</html>