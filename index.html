<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<title>Проверка CAPTCHA</title>
	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
	<script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
	<script src="https://telegram.org/js/telegram-web-app.js"></script>
	<style>
		html,
		body {
			margin: 0;
			padding: 0;
			height: 100vh;
			width: 100vw;
			touch-action: manipulation;
			-webkit-text-size-adjust: 100%;
			-ms-text-size-adjust: 100%;
		}

		body {
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 0;
			box-sizing: border-box;
			background-color: var(--bg-color, #ffffff);
			transition: background-color 0.3s ease;
		}

		.captcha-wrapper {
			width: 100%;
			max-width: 360px;
			padding: 0 16px;
			box-sizing: border-box;
			display: flex;
			flex-direction: column;
			align-items: center;
			overflow-x: hidden;
		}

		.version-watermark {
			margin-top: 16px;
			text-align: center;
			font-size: 10px;
			color: rgba(128, 128, 128, 0.5);
			font-family: monospace;
			cursor: pointer;
			transition: color 0.2s ease;
			user-select: none;
		}

		.version-watermark:hover {
			color: rgba(128, 128, 128, 0.8);
		}

		.version-watermark:active {
			color: rgba(128, 128, 128, 1);
		}

		.status-indicator {
			margin-top: 12px;
			padding: 8px 12px;
			text-align: center;
			font-size: 12px;
			border-radius: 6px;
			font-family: system-ui, -apple-system, sans-serif;
			min-height: 16px;
			transition: all 0.3s ease;
			max-width: 100%;
			width: 100%;
			box-sizing: border-box;
		}

		.status-loading {
			background: rgba(0, 123, 255, 0.1);
			color: #007bff;
			border: 1px solid rgba(0, 123, 255, 0.3);
		}

		.status-success {
			background: rgba(40, 167, 69, 0.1);
			color: #28a745;
			border: 1px solid rgba(40, 167, 69, 0.3);
		}

		.status-error {
			background: rgba(220, 53, 69, 0.1);
			color: #dc3545;
			border: 1px solid rgba(220, 53, 69, 0.3);
			border-radius: 6px;
			white-space: pre-wrap;
			text-align: left;
			font-family: monospace;
			font-size: 11px;
			max-width: 100%;
			width: 100vw;
			box-sizing: border-box;
			word-wrap: break-word;
			word-break: break-all;
			overflow-wrap: break-word;
			margin-left: calc(-50vw + 50%);
			margin-right: calc(-50vw + 50%);
			padding: 8px 4px;
			max-height: 60vh;
			overflow-y: auto;
			position: relative;
			z-index: 9999;
		}

		.copy-button {
			background: #dc3545;
			color: white;
			border: 1px solid rgba(220, 53, 69, 0.3);
			border-radius: 6px;
			padding: 12px;
			font-size: 12px;
			cursor: pointer;
			font-family: system-ui, -apple-system, sans-serif;
			transition: background-color 0.2s ease;
			width: 100%;
			max-width: 100%;
			box-sizing: border-box;
			margin-top: 8px;
			margin-bottom: 0;
			text-align: center;
			font-weight: 500;
			display: block;
			outline: none;
		}

		.copy-button:hover {
			background: #c82333 !important;
		}

		.copy-button:active {
			background: #bd2130 !important;
		}

		.copy-button.copied {
			background: #28a745 !important;
		}

		.status-hidden {
			opacity: 0;
			height: 0;
			margin: 0;
			padding: 0;
		}
	</style>
</head>

<body>
	<div class="captcha-wrapper">
		<div id="captcha-container"></div>
		<div id="status-indicator" class="status-indicator status-hidden"></div>
		<button id="copy-button" class="copy-button status-hidden">копировать</button>
		<div class="version-watermark" onclick="showStatus('error', showDebugInfo())">v1.2</div>
	</div>

	<script>
		let platform = 'unknown';
		let rawData = '';
		let theme = 'light';
		let submitting = false; // защита от двойной отправки
		let activeCaptchaType = 'unknown'; // отслеживаем какой виджет капчи загружен
		let captchaInitialized = false; // защита от повторной инициализации
		let captchaRenderTimeout = null; // таймаут для проверки рендеринга
		
		// переключатель капчи для VK: true = Turnstile, false = hCaptcha
		const useCloudflareForVK = true;
		
		// отладочная информация о среде выполнения
		const debugInfo = 
		{
			userAgent: navigator.userAgent,
			isWebView: /wv/.test(navigator.userAgent) || /WebView/.test(navigator.userAgent) || 
					   (window.navigator.standalone === false && /Mobile/.test(navigator.userAgent)),
			isVKApp: /VKApp/.test(navigator.userAgent) || window.vkBridge !== undefined,
			isAndroid: /Android/.test(navigator.userAgent),
			isIOS: /iPhone|iPad|iPod/.test(navigator.userAgent),
			platform: window.location.href.includes('vk.com') ? 'vk' : 'unknown',
			location: window.location.href,
			referrer: document.referrer,
			windowFeatures: {
				width: window.innerWidth,
				height: window.innerHeight,
				devicePixelRatio: window.devicePixelRatio
			},
			allowsThirdPartyScripts: true, // будем проверять позже
			cspBlocked: false,
			networkBlocked: false,
			scriptsLoaded: {
				turnstile: false,
				hcaptcha: false
			},
			loadAttempts: {
				turnstile: 0,
				hcaptcha: 0
			},
			errors: [],
			logs: []
		};

		// функция для добавления логов 
		function addLog(message) 
		{
			const timestamp = new Date().toISOString().substr(11, 12);
			const logEntry = `[${timestamp}] ${message}`;
			debugInfo.logs.push(logEntry);
			console.log(`[DEBUG] ${message}`);
			
			// ограничиваем количество логов до 50
			if (debugInfo.logs.length > 50) 
			{
				debugInfo.logs.shift();
			}
		}

		function showDebugInfo() 
		{
			const debugText = [
				'=== ОТЛАДОЧНАЯ ИНФОРМАЦИЯ ===',
				`user agent: ${debugInfo.userAgent}`,
				`location: ${debugInfo.location}`,
				`referrer: ${debugInfo.referrer}`,
				`webview: ${debugInfo.isWebView}`,
				`vk app: ${debugInfo.isVKApp}`,
				`android: ${debugInfo.isAndroid}`,
				`ios: ${debugInfo.isIOS}`,
				`window: ${debugInfo.windowFeatures.width}x${debugInfo.windowFeatures.height}`,
				`dpr: ${debugInfo.windowFeatures.devicePixelRatio}`,
				`scripts loaded: turnstile=${debugInfo.scriptsLoaded.turnstile}, hcaptcha=${debugInfo.scriptsLoaded.hcaptcha}`,
				`load attempts: turnstile=${debugInfo.loadAttempts.turnstile}, hcaptcha=${debugInfo.loadAttempts.hcaptcha}`,
				`active captcha type: ${activeCaptchaType}`,
				`csp blocked: ${debugInfo.cspBlocked}`,
				`network blocked: ${debugInfo.networkBlocked}`,
				`third party scripts: ${debugInfo.allowsThirdPartyScripts}`,
				`errors: ${debugInfo.errors.length > 0 ? debugInfo.errors.join('; ') : 'none'}`,
				'',
				'=== EXECUTION LOGS ===',
				...(debugInfo.logs.length > 0 ? debugInfo.logs : ['no logs yet']),
				'================================'
			].join('\n');
			return debugText;
		}

		function showStatus(type, message) 
		{
			const indicator = document.getElementById('status-indicator');
			const copyButton = document.getElementById('copy-button');

			// добавляем отладочную информацию к ошибкам в webview
			if (type === 'error' && debugInfo.isWebView) 
			{
				message = message + '\n\n' + showDebugInfo();
			}

			indicator.className = `status-indicator status-${type}`;
			indicator.textContent = message;

			if (type === 'error') 
			{
				copyButton.className = 'copy-button';
				copyButton.onclick = () => copyErrorText(message, copyButton);
			} else 
			{
				copyButton.className = 'copy-button status-hidden';
			}
		}

		function hideStatus() {
			const indicator = document.getElementById('status-indicator');
			const copyButton = document.getElementById('copy-button');

			indicator.className = 'status-indicator status-hidden';
			copyButton.className = 'copy-button status-hidden';
		}

		async function copyErrorText(text, button) {
			try {
				await navigator.clipboard.writeText(text);
				const originalText = button.textContent;
				button.textContent = 'скопировано';
				button.classList.add('copied');

				setTimeout(() => {
					button.textContent = originalText;
					button.classList.remove('copied');
				}, 2000);
			} catch (err) {
				const textArea = document.createElement('textarea');
				textArea.value = text;
				textArea.style.position = 'fixed';
				textArea.style.left = '-999999px';
				textArea.style.top = '-999999px';
				document.body.appendChild(textArea);
				textArea.focus();
				textArea.select();

				try {
					document.execCommand('copy');
					button.textContent = 'скопировано';
					button.classList.add('copied');

					setTimeout(() => {
						button.textContent = 'копировать';
						button.classList.remove('copied');
					}, 2000);
				} catch (err2) {
					button.textContent = 'ошибка';
					setTimeout(() => {
						button.textContent = 'копировать';
					}, 2000);
				}

				document.body.removeChild(textArea);
			}
		}

		// проверка CSP и блокировки скриптов
		function checkCSPAndScriptBlocking() 
		{
			return new Promise(async (resolve) => 
			{
				// проверяем CSP
				const testScript = document.createElement('script');
				testScript.src = 'data:text/javascript;base64,'; // пустой data URI
				testScript.onload = () => 
				{
					debugInfo.allowsThirdPartyScripts = true;
					debugInfo.cspBlocked = false;
				};
				testScript.onerror = () => 
				{
					debugInfo.allowsThirdPartyScripts = false;
					debugInfo.cspBlocked = true;
					debugInfo.errors.push('CSP blocks data URIs');
				};
				
				document.head.appendChild(testScript);
				
				// ждём немного для CSP проверки
				await new Promise(r => setTimeout(r, 500));
				
				// проверяем сетевую доступность к серверам капчи
				try 
				{
					const turnstileCheck = fetch('https://challenges.cloudflare.com/turnstile/v0/api.js', { 
						method: 'HEAD', 
						mode: 'no-cors',
						cache: 'no-cache'
					}).catch(() => false);
					
					const hcaptchaCheck = fetch('https://hcaptcha.com/1/api.js', { 
						method: 'HEAD', 
						mode: 'no-cors',
						cache: 'no-cache'
					}).catch(() => false);
					
					const [turnstileOk, hcaptchaOk] = await Promise.allSettled([turnstileCheck, hcaptchaCheck]);
					
					if (turnstileOk.status === 'rejected' && hcaptchaOk.status === 'rejected') 
					{
						debugInfo.networkBlocked = true;
						debugInfo.errors.push('Network access to captcha servers blocked');
					}
				} catch (e) 
				{
					debugInfo.errors.push(`Network check failed: ${e.message}`);
				}
				
				resolve();
			});
		}

		// функция для безопасной загрузки скриптов с фолбэками
		function loadScriptWithFallback(src, onLoad, onError, scriptType = 'unknown') 
		{
			// увеличиваем счётчик попыток
			if (scriptType === 'turnstile') debugInfo.loadAttempts.turnstile++;
			if (scriptType === 'hcaptcha') debugInfo.loadAttempts.hcaptcha++;
			
			const script = document.createElement('script');
			script.async = true;
			script.defer = true;
			
			let loaded = false;
			let timeoutId;
			
			const cleanup = () => 
			{
				if (timeoutId) clearTimeout(timeoutId);
				script.onload = null;
				script.onerror = null;
			};
			
			script.onload = () => 
			{
				if (loaded) return;
				loaded = true;
				cleanup();
				addLog(`Script loaded successfully: ${src}`);
				if (onLoad) onLoad();
			};
			
			script.onerror = (error) => 
			{
				if (loaded) return;
				loaded = true;
				cleanup();
				const errorMsg = `Script load error: ${src}`;
				addLog(errorMsg);
				debugInfo.errors.push(errorMsg);
				if (onError) onError();
			};
			
			// таймаут для webview, где скрипты могут блокироваться молча
			timeoutId = setTimeout(() => 
			{
				if (loaded) return;
				loaded = true;
				cleanup();
				const timeoutMsg = `Script load timeout: ${src}`;
				addLog(timeoutMsg);
				debugInfo.errors.push(timeoutMsg);
				if (onError) onError();
			}, 15000); // увеличил таймаут до 15 секунд
			
			addLog(`Loading script: ${src}`);
			script.src = src;
			document.head.appendChild(script);
		}

		// функция для парсинга VK параметров из URL
		function getVKLaunchParams() 
		{
			const params = new URLSearchParams(window.location.search);
			const vkParams = {};
			
			// собираем все параметры с префиксом 'vk_' и 'sign'
			for (const [key, value] of params.entries()) 
			{
				if (key.startsWith('vk_') || key === 'sign') 
				{
					vkParams[key] = value;
				}
			}
			
			addLog(`VK params from URL: ${Object.keys(vkParams).length} parameters found`);
			return vkParams;
		}

		// начальный лог
		addLog('Application started');
		addLog(`Detected platform: isTelegram=${!!window.Telegram?.WebApp?.initData}, isVK=${!window.Telegram?.WebApp?.initData}`);
		
		// принудительно очищаем все возможные остатки от предыдущих сессий
		const captchaContainer = document.getElementById('captcha-container');
		if (captchaContainer) 
		{
			captchaContainer.innerHTML = '';
			addLog('Cleared captcha container on startup');
		}

		const isTelegram = window.Telegram?.WebApp?.initData;
		const isVK = !isTelegram;

		function applyTheme(theme) 
		{
			document.body.style.setProperty('--bg-color', theme === 'dark' ? '#000000' : '#ffffff');
			// НЕ перерендериваем капчи при смене темы - это вызывает дублирование
			// Капчи должны рендериться только один раз при загрузке приложения
			addLog(`Theme applied: ${theme}, but skipping captcha re-render`);
		}

		function insertTelegramCaptcha() 
		{
			const container = document.getElementById('captcha-container');
			// создаём элемент без data-атрибутов для предотвращения автоматического рендера
			container.innerHTML = '';
			const turnstileDiv = document.createElement('div');
			turnstileDiv.id = 'telegram-turnstile';
			turnstileDiv.className = 'cf-turnstile-manual';
			container.appendChild(turnstileDiv);

			const existingScript = document.querySelector('script[src*="turnstile"]');
			if (!existingScript) 
			{
				showStatus('loading', 'загружается turnstile...');
				loadScriptWithFallback(
					'https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit',
					() => 
					{
						debugInfo.scriptsLoaded.turnstile = true;
						activeCaptchaType = 'turnstile';
						
						// принудительно рендерим turnstile виджет для telegram
						setTimeout(() => 
						{
							addLog('Attempting to render Turnstile widget for Telegram...');
							if (window.turnstile && window.turnstile.render) 
							{
								const container = document.getElementById('telegram-turnstile');
								if (container) 
								{
									try 
									{
										addLog('Rendering Turnstile widget with API for Telegram...');
										window.turnstile.render(container, {
											sitekey: '0x4AAAAAABvVfFdKvgN--jG6',
											callback: onCaptchaSuccess,
											theme: theme === 'dark' ? 'dark' : 'light'
										});
										addLog('Turnstile widget rendered successfully');
									} catch (e) 
									{
										addLog(`Turnstile render error: ${e.message}`);
									}
								}
							}
						}, 100);
						
						hideStatus();
					},
					() => 
					{
						debugInfo.scriptsLoaded.turnstile = false;
						showStatus('error', 'не удалось загрузить turnstile скрипт. возможно заблокирован в webview.');
					},
					'turnstile'
				);
			}
		}

		function insertVKCaptcha() 
		{
			// защита от повторных вызовов
			if (captchaInitialized) 
			{
				addLog('Captcha already initialized, skipping...');
				return;
			}
			
			addLog(`insertVKCaptcha called, useCloudflareForVK: ${useCloudflareForVK}`);
			captchaInitialized = true;
			
			if (useCloudflareForVK) 
			{
				addLog('Calling insertVKTurnstileCaptcha');
				insertVKTurnstileCaptcha();
			} else 
			{
				addLog('Calling insertVKHCaptcha');
				insertVKHCaptcha();
			}
		}
		
		function insertVKTurnstileCaptcha() 
		{
			addLog('insertVKTurnstileCaptcha called');
			
			// строгая защита - проверяем наличие любых дочерних элементов в контейнере
			const container = document.getElementById('captcha-container');
			if (container.children.length > 0) 
			{
				addLog('Captcha container not empty, skipping render to prevent duplicates');
				return;
			}
			
			// уникальный ID для предотвращения конфликтов
			const uniqueId = 'turnstile-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
			addLog(`Creating Turnstile widget with unique ID: ${uniqueId}`);
			
			// создаём новый div для turnstile с уникальным ID
			// НЕ используем data-* атрибуты чтобы избежать автоматического рендера
			const turnstileDiv = document.createElement('div');
			turnstileDiv.id = uniqueId;
			turnstileDiv.className = 'cf-turnstile-manual'; // изменили класс
			// НЕ добавляем data-sitekey и другие data-* атрибуты
			container.appendChild(turnstileDiv);
			
			const existingScript = document.querySelector('script[src*="turnstile"]');
			addLog(`Existing turnstile script: ${existingScript ? 'found' : 'not found'}`);
			
			if (!existingScript) 
			{
				addLog('Loading turnstile script...');
				showStatus('loading', 'загружается turnstile для vk...');
				loadScriptWithFallback(
					'https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit',
					() => 
					{
						addLog('Turnstile script loaded successfully');
						debugInfo.scriptsLoaded.turnstile = true;
						activeCaptchaType = 'turnstile';
						
						// принудительно рендерим turnstile виджет (особенно для iOS WebView)
						setTimeout(() => 
						{
							addLog('Attempting to render Turnstile widget...');
							if (window.turnstile && window.turnstile.render) 
							{
								const containerElement = document.getElementById(uniqueId);
								if (containerElement) 
								{
									try 
									{
										addLog(`Rendering Turnstile widget with API on container: ${uniqueId}`);
										// используем render с конкретным элементом
										window.turnstile.render(containerElement, {
											sitekey: '0x4AAAAAABvVfFdKvgN--jG6',
											callback: onCaptchaSuccess,
											theme: theme === 'dark' ? 'dark' : 'light'
										});
										addLog('Turnstile widget rendered successfully');
										// отменяем таймаут проверки, т.к. рендеринг прошёл успешно
										if (captchaRenderTimeout) 
										{
											clearTimeout(captchaRenderTimeout);
											captchaRenderTimeout = null;
										}
									} catch (e) 
									{
										addLog(`Turnstile render error: ${e.message}`);
										// если turnstile не рендерится на iOS, переключаемся на hCaptcha
										if (debugInfo.isIOS) 
										{
											addLog('Switching to hCaptcha due to iOS Turnstile render failure');
											captchaInitialized = false; // сбрасываем флаг
											setTimeout(() => insertVKHCaptcha(), 500);
										}
									}
								} else 
								{
									addLog(`Turnstile container ${uniqueId} not found`);
									// если контейнер не найден на iOS, переключаемся на hCaptcha
									if (debugInfo.isIOS) 
									{
										addLog('Switching to hCaptcha due to missing Turnstile container on iOS');
										captchaInitialized = false; // сбрасываем флаг
										setTimeout(() => insertVKHCaptcha(), 500);
									}
								}
							} else 
							{
								addLog('Turnstile API not available for manual render');
								// если API недоступен на iOS, переключаемся на hCaptcha
								if (debugInfo.isIOS) 
								{
									addLog('Switching to hCaptcha due to unavailable Turnstile API on iOS');
									captchaInitialized = false; // сбрасываем флаг
									setTimeout(() => insertVKHCaptcha(), 500);
								}
							}
						}, 100);
						
						// отменяем предыдущий таймаут если есть
						if (captchaRenderTimeout) 
						{
							clearTimeout(captchaRenderTimeout);
						}
						
						// дополнительная проверка через 3 секунды - рендерился ли виджет
						captchaRenderTimeout = setTimeout(() => 
						{
							const widget = document.querySelector('.cf-turnstile iframe') || document.querySelector('.cf-turnstile div[data-sitekey]');
							if (!widget && debugInfo.isIOS && activeCaptchaType !== 'hcaptcha') 
							{
								addLog('Turnstile widget not rendered after 3 seconds on iOS, switching to hCaptcha');
								captchaInitialized = false; // сбрасываем флаг чтобы разрешить hCaptcha
								insertVKHCaptcha();
							} else if (widget) 
							{
								addLog('Turnstile widget successfully rendered and visible');
							}
						}, 3000);
						
						hideStatus();
					},
					() => 
					{
						addLog('Turnstile script failed to load');
						debugInfo.scriptsLoaded.turnstile = false;
						// если turnstile не загрузился в VK, переключаемся на hCaptcha
						if (debugInfo.isWebView || debugInfo.isAndroid) 
						{
							addLog('Switching to hCaptcha due to failure');
							captchaInitialized = false; // сбрасываем флаг
							showStatus('loading', 'turnstile заблокирован, переключаемся на hcaptcha...');
							setTimeout(() => insertVKHCaptcha(), 1000);
						} else 
						{
							showStatus('error', 'не удалось загрузить turnstile скрипт.');
						}
					},
					'turnstile'
				);
			} else 
			{
				addLog('Turnstile script already exists, skipping load');
				hideStatus();
			}
		}
		
		function insertVKHCaptcha() 
		{
			addLog('insertVKHCaptcha called');
			
			const container = document.getElementById('captcha-container');
			container.innerHTML = `
        <div class="h-captcha" 
             data-sitekey="5ae63666-6d46-47b0-ad48-a96829a83a7a" 
             data-callback="onCaptchaSuccess" 
             data-theme="${theme}">
        </div>`;

			const existingScript = document.querySelector('script[src*="hcaptcha"]');
			if (existingScript) 
			{
				addLog('Removing existing hCaptcha script');
				existingScript.remove();
			}

			addLog('Loading hCaptcha script...');
			showStatus('loading', 'загружается hcaptcha...');
			loadScriptWithFallback(
				'https://hcaptcha.com/1/api.js?hl=ru&onload=hcaptchaLoaded',
				() => 
				{
					addLog('hCaptcha script loaded successfully');
					debugInfo.scriptsLoaded.hcaptcha = true;
					activeCaptchaType = 'hcaptcha';
					// hideStatus будет вызван в hcaptchaLoaded
				},
				() => 
				{
					addLog('hCaptcha script failed to load');
					debugInfo.scriptsLoaded.hcaptcha = false;
					showStatus('error', 'не удалось загрузить hcaptcha скрипт. возможно заблокирован в webview.');
				},
				'hcaptcha'
			);
		}

		function hcaptchaLoaded() 
		{
			addLog('hcaptchaLoaded callback called');
			const container = document.querySelector('.h-captcha');
			addLog(`hCaptcha container found: ${container ? 'yes' : 'no'}`);
			addLog(`window.hcaptcha exists: ${window.hcaptcha ? 'yes' : 'no'}`);
			
			if (container && window.hcaptcha) 
			{
				try 
				{
					addLog('Rendering hCaptcha widget...');
					window.hcaptcha.render(container);
					addLog('hCaptcha widget rendered successfully');
					hideStatus();
				} catch (e) 
				{
					addLog(`hCaptcha render error: ${e.message}`);
					showStatus('error', `hcaptcha render error: ${e.message}`);
				}
			} else 
			{
				addLog('hCaptcha render failed - missing container or hcaptcha object');
				showStatus('error', 'hcaptcha загружен, но не найден контейнер или объект hcaptcha');
			}
		}

		if (isTelegram) {
			const tg = window.Telegram.WebApp;
			platform = 'tg';
			rawData = encodeURIComponent(JSON.stringify(tg.initDataUnsafe));
			theme = tg.colorScheme;
			tg.ready();

			tg.onEvent('themeChanged', () => {
				theme = tg.colorScheme;
				applyTheme(theme);
				insertTelegramCaptcha();
			});

			applyTheme(theme);
			insertTelegramCaptcha();

		} else if (isVK) 
		{
			platform = 'vk';
			addLog('Starting VK initialization...');
			addLog(`vkBridge available: ${typeof vkBridge !== 'undefined'}`);

			// загружаем капчу сразу, не дожидаясь VK Bridge
			addLog('Loading captcha immediately (not waiting for VK Bridge)');
			platform = 'vk';
			theme = 'light';
			
			// получаем VK параметры из URL вместо ожидания vkBridge
			const vkLaunchParams = getVKLaunchParams();
			rawData = encodeURIComponent(JSON.stringify(vkLaunchParams));
			addLog('Using VK params from URL for rawData');
			
			insertVKCaptcha();

			// параллельно пытаемся инициализировать VK Bridge для получения темы и данных
			(async () => 
			{
				try 
				{
					// проверяем доступность vkBridge
					if (typeof vkBridge === 'undefined') 
					{
						addLog('vkBridge not available, using fast mode only');
						return;
					}

					addLog('Trying VK Bridge init in background...');
					
					// добавляем таймаут для VK Bridge инициализации
					const initPromise = vkBridge.send('VKWebAppInit');
					const timeoutPromise = new Promise((_, reject) => 
						setTimeout(() => reject(new Error('VK Bridge init timeout')), 3000)
					);
					
					try 
					{
						await Promise.race([initPromise, timeoutPromise]);
						addLog('VK Bridge initialized successfully');
						
						addLog('Getting launch params...');
						const launchParams = await vkBridge.send('VKWebAppGetLaunchParams');
						rawData = encodeURIComponent(JSON.stringify(launchParams));
						addLog('Launch params received, updating rawData');

						addLog('Getting config...');
						const config = await vkBridge.send('VKWebAppGetConfig');
						const newTheme = config.scheme?.includes('dark') ? 'dark' : 'light';
						if (newTheme !== theme) 
						{
							theme = newTheme;
							applyTheme(theme);
							addLog(`Theme updated to: ${theme}`);
						}

						vkBridge.subscribe(e => 
						{
							if (e.detail.type === 'VKWebAppUpdateConfig') 
							{
								const newScheme = e.detail.data.scheme || 'bright_light';
								const newTheme = newScheme.includes('dark') ? 'dark' : 'light';
								if (newTheme !== theme) 
								{
									theme = newTheme;
									applyTheme(theme);
									addLog(`Theme changed to: ${newTheme}`);
									// НЕ перерендериваем капчу при смене темы - это вызывает дублирование
									// insertVKCaptcha(); // УБРАНО
								}
							}
						});

					} catch (initError) 
					{
						addLog(`VK Bridge init failed in background: ${initError.message}`);
						// не проблема, капча уже загружена
					}
				} catch (err) 
				{
					addLog(`VK background init error: ${err.toString()}`);
					// не критично, основная функциональность уже работает
				}
			})();
		}

		async function onCaptchaSuccess(token) {
			addLog(`onCaptchaSuccess called with token: ${token ? token.substring(0, 20) + '...' : 'null'}`);
			
			if (submitting) {
				addLog('Already submitting, skipping duplicate');
				return; // не шлём дубли
			}
			submitting = true;

			showStatus('loading', 'проверяем капчу...');
			const encodedToken = encodeURIComponent(token);

			const endPoint = 'https://api.cf-botbandit.com/captcha/';
			// const endPoint = 'https://slots.botbandit.com/captcha.php';

			const url = `${endPoint}?captcha=${encodedToken}&rawData=${rawData}&platform=${platform}&captchaType=${activeCaptchaType}`;
			
			addLog(`Sending request with captcha type: ${activeCaptchaType}`);

			try {
				showStatus('loading', 'загрузка...');

				const controller = new AbortController();
				const timeoutId = setTimeout(() => {
					controller.abort();
					showStatus('error', 'превышено время ожидания ответа от сервера (30 сек)');
					submitting = false;
				}, 30000);

				const res = await fetch(url, {
					signal: controller.signal,
					method: 'GET',
					mode: 'cors',
					headers: { 'Accept': 'application/json, text/plain;q=0.9, */*;q=0.8' },
					cache: 'no-store'
				});

				clearTimeout(timeoutId);
				showStatus('loading', 'обработка...');

				const text = await res.text();
				let data = null;
				try { data = JSON.parse(text); } catch (_) {}

				if (res.ok && data && data.success) {
					showStatus('success', 'проверка пройдена! можно закрыть это окно.');
					setTimeout(() => {
						if (platform === 'tg') {
							window.Telegram.WebApp.sendData('verified');
							setTimeout(() => { window.Telegram.WebApp.close(); }, 50);
						} else if (platform === 'vk') {
							vkBridge.send('VKWebAppClose', { status: 'success' });
						}
					}, 50);
				} else {
					showStatus('error', (data ? JSON.stringify(data, null, 2) : (text || `HTTP ${res.status}`)) + `\n\nплатформа: ${platform}\nurl: ${url}`);
					if (window.hcaptcha && platform === 'vk') window.hcaptcha.reset();
					if (window.turnstile && platform === 'tg') window.turnstile.reset();
					// небольшая пауза, чтобы Cloudflare/Google не засчитал дубликат
					setTimeout(() => { submitting = false; }, 400);
					return;
				}
			} catch (e) {
				if (e.name === 'AbortError') return; // таймаут уже показали
				showStatus('error', `ошибка сети: ${String(e)}\n\nплатформа: ${platform}\nurl: ${url}`);
				if (window.hcaptcha && platform === 'vk') window.hcaptcha.reset();
				if (window.turnstile && platform === 'tg') window.turnstile.reset();
				setTimeout(() => { submitting = false; }, 400);
				return;
			}

			// успех — можно снова принимать попытки (если вдруг не закрыли окно)
			setTimeout(() => { submitting = false; }, 1000);
		}
	</script>
</body>

</html>